
#!/usr/bin/env python3
"""
ARR Interest Calculator (SONIA / SOFR) - Lookback, Compounded-in-Arrears

GUI Version with File Selection and User-Friendly Interface

Usage:
  Run the script and use the graphical interface.

What it does:
  â€¢ Reads a CSV of daily SONIA or SOFR rates (date in first column, rate in second).
  â€¢ Computes interest for an interest period using *compounded in arrears* with a
    business-day lookback (without observation shift), which is the market convention
    recommended for loans.
  â€¢ Assumes day count ACT/365F for SONIA and ACT/360 for SOFR.
  â€¢ Lets you add a **Margin** and a **Credit Adjustment Spread (CAS)** (both per annum).
    These are **not compounded**; they are added after compounding the RFR and applied
    using the day-count fraction over the interest period.
  â€¢ Supports a **single margin change** during the interest period (step-up/step-down):
    from an effective date (inclusive), the new margin applies; before that date, the
    original margin applies.

Notes:
  â€¢ Rates may be given as percents (e.g., 5.12) or decimals (e.g., 0.0512). Both are accepted.
  â€¢ The CSV's first column must be the effective date (YYYY-MM-DD). The second column
    must be the daily rate. Extra columns are ignored.
  â€¢ The CSV implicitly defines the "business days" calendar (rows present â‡’ business day).
  â€¢ Lookback is in *business days* (>= 1). For each calendar day in the accrual period,
    the script uses the rate from (that day's prior business day shifted back by `lookback`). 
  â€¢ Interest amount = Principal Ã— [ (CompoundedFactor âˆ’ 1)  +  (Margin + CAS) Ã— (dc/N) ],
    where Margin (and optional MarginAfterChange) and CAS are per annum and are NOT compounded.

Limitations:
  â€¢ Floors, lockout days, observation shift, multiple margin steps, and payment lag are NOT included but can be added.

Author: Generated by ChatGPT
License: MIT
"""
import csv
import os
import sys
import json
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from datetime import datetime, date, timedelta
from decimal import Decimal, getcontext, ROUND_HALF_UP, InvalidOperation
from collections import OrderedDict
from typing import List, Dict, Optional, Tuple
import urllib.request
import urllib.parse
import re

# Try to import certifi for SSL certificate handling
try:
    import certifi
    HAS_CERTIFI = True
except ImportError:
    HAS_CERTIFI = False

# Try to import tkcalendar, fall back to basic date picker if not available
try:
    from tkcalendar import DateEntry
    HAS_TKCALENDAR = True
except ImportError:
    HAS_TKCALENDAR = False

# Try to import beautifulsoup for web scraping, fall back to regex if not available
try:
    from bs4 import BeautifulSoup
    HAS_BEAUTIFULSOUP = True
except ImportError:
    HAS_BEAUTIFULSOUP = False

getcontext().prec = 34  # high precision for financial compounding

class DatePicker:
    """Custom date picker widget that works with or without tkcalendar."""
    
    def __init__(self, parent, **kwargs):
        self.parent = parent
        self.date_var = kwargs.get('textvariable', tk.StringVar())
        self.width = kwargs.get('width', 15)
        
        if HAS_TKCALENDAR:
            # Use tkcalendar DateEntry if available
            self.widget = DateEntry(
                parent,
                textvariable=self.date_var,
                width=self.width,
                background='darkblue',
                foreground='white',
                borderwidth=2,
                date_pattern='yyyy-mm-dd',
                firstweekday='monday'
            )
        else:
            # Fallback to basic entry with calendar popup
            self.frame = ttk.Frame(parent)
            self.entry = ttk.Entry(self.frame, textvariable=self.date_var, width=self.width)
            self.entry.pack(side=tk.LEFT)
            
            self.calendar_btn = ttk.Button(self.frame, text="ðŸ“…", width=3, command=self.show_calendar)
            self.calendar_btn.pack(side=tk.RIGHT, padx=(2, 0))
            
            self.widget = self.frame
    
    def show_calendar(self):
        """Show a simple calendar popup."""
        if not HAS_TKCALENDAR:
            self.show_basic_calendar()
    
    def show_basic_calendar(self):
        """Show a basic calendar popup using tkinter."""
        calendar_window = tk.Toplevel(self.parent)
        calendar_window.title("Select Date")
        calendar_window.geometry("300x250")
        calendar_window.transient(self.parent)
        calendar_window.grab_set()
        
        # Center the window
        calendar_window.geometry("+%d+%d" % (
            self.parent.winfo_rootx() + 50,
            self.parent.winfo_rooty() + 50
        ))
        
        # Get current date
        current_date = datetime.now()
        if self.date_var.get():
            try:
                current_date = datetime.strptime(self.date_var.get(), "%Y-%m-%d")
            except:
                pass
        
        year = current_date.year
        month = current_date.month
        
        # Navigation frame
        nav_frame = ttk.Frame(calendar_window)
        nav_frame.pack(fill=tk.X, padx=10, pady=5)
        
        prev_btn = ttk.Button(nav_frame, text="<", command=lambda: self.change_month(calendar_window, -1))
        prev_btn.pack(side=tk.LEFT)
        
        month_label = ttk.Label(nav_frame, text=f"{current_date.strftime('%B %Y')}", font=("Segoe UI", 10, "bold"))
        month_label.pack(side=tk.LEFT, expand=True)
        
        next_btn = ttk.Button(nav_frame, text=">", command=lambda: self.change_month(calendar_window, 1))
        next_btn.pack(side=tk.RIGHT)
        
        # Calendar grid
        self.calendar_frame = ttk.Frame(calendar_window)
        self.calendar_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Store references
        self.calendar_window = calendar_window
        self.month_label = month_label
        self.current_year = year
        self.current_month = month
        
        self.update_calendar()
    
    def change_month(self, window, delta):
        """Change the displayed month."""
        self.current_month += delta
        if self.current_month > 12:
            self.current_month = 1
            self.current_year += 1
        elif self.current_month < 1:
            self.current_month = 12
            self.current_year -= 1
        
        self.update_calendar()
    
    def update_calendar(self):
        """Update the calendar display."""
        # Clear existing widgets
        for widget in self.calendar_frame.winfo_children():
            widget.destroy()
        
        # Day headers
        days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        for i, day in enumerate(days):
            label = ttk.Label(self.calendar_frame, text=day, font=("Segoe UI", 8, "bold"))
            label.grid(row=0, column=i, padx=1, pady=1)
        
        # Get first day of month and number of days
        first_day = date(self.current_year, self.current_month, 1)
        if self.current_month == 12:
            last_day = date(self.current_year + 1, 1, 1) - timedelta(days=1)
        else:
            last_day = date(self.current_year, self.current_month + 1, 1) - timedelta(days=1)
        
        # Calculate starting position (Monday = 0)
        start_pos = (first_day.weekday() - 0) % 7
        
        # Update month label
        self.month_label.config(text=f"{first_day.strftime('%B %Y')}")
        
        # Create day buttons
        day_num = 1
        for week in range(6):  # 6 weeks max
            for day in range(7):
                if week == 0 and day < start_pos:
                    # Empty space before first day
                    continue
                elif day_num > last_day.day:
                    # Past end of month
                    break
                
                btn = ttk.Button(
                    self.calendar_frame, 
                    text=str(day_num),
                    width=3,
                    command=lambda d=day_num: self.select_date(d)
                )
                btn.grid(row=week+1, column=day, padx=1, pady=1)
                day_num += 1
    
    def select_date(self, day):
        """Select a date and close the calendar."""
        selected_date = date(self.current_year, self.current_month, day)
        self.date_var.set(selected_date.strftime("%Y-%m-%d"))
        self.calendar_window.destroy()
    
    def pack(self, **kwargs):
        """Pack the widget."""
        self.widget.pack(**kwargs)
    
    def grid(self, **kwargs):
        """Grid the widget."""
        self.widget.grid(**kwargs)
    
    def place(self, **kwargs):
        """Place the widget."""
        self.widget.place(**kwargs)

# ANSI color codes for better output
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'

def print_header(text: str):
    """Print a formatted header."""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'='*60}")
    print(f"{text:^60}")
    print(f"{'='*60}{Colors.END}\n")

def print_section(text: str):
    """Print a formatted section header."""
    print(f"\n{Colors.BLUE}{Colors.BOLD}{text}{Colors.END}")
    print(f"{Colors.BLUE}{'-' * len(text)}{Colors.END}")

def print_success(text: str):
    """Print success message."""
    print(f"{Colors.GREEN}âœ“ {text}{Colors.END}")

def print_warning(text: str):
    """Print warning message."""
    print(f"{Colors.YELLOW}âš  {text}{Colors.END}")

def print_error(text: str):
    """Print error message."""
    print(f"{Colors.RED}âœ— {text}{Colors.END}")

class ARRCalculatorGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ARR Interest Calculator - SONIA/SOFR")
        self.root.geometry("900x750")
        self.root.resizable(True, True)
        
        # Configure modern styling
        self.setup_styles()
        
        # Set icon if available
        try:
            self.root.iconbitmap("calculator.ico")
        except:
            pass
        
        # Variables
        self.csv_path = tk.StringVar()
        self.data_source = tk.StringVar(value="csv")  # "csv" or "gdrive"
        self.gdrive_url = tk.StringVar()
        self.principal = tk.StringVar(value="1000000.00")
        self.start_date = tk.StringVar(value="2024-01-01")
        self.end_date = tk.StringVar(value="2024-04-01")
        self.pricing_option = tk.StringVar(value="SONIA")
        self.lookback = tk.StringVar(value="5")
        self.margin = tk.StringVar(value="2.00")
        self.cas = tk.StringVar(value="0.10")
        self.margin_change = tk.BooleanVar(value=False)
        self.margin_after = tk.StringVar(value="2.25")
        self.margin_change_date = tk.StringVar(value="2024-02-15")
        
        self.create_widgets()
        
    def setup_styles(self):
        """Configure modern styling for the application."""
        style = ttk.Style()
        
        # Configure modern colors
        style.configure("Title.TLabel", font=("Segoe UI", 18, "bold"), foreground="#2c3e50")
        style.configure("Subtitle.TLabel", font=("Segoe UI", 11), foreground="#7f8c8d")
        style.configure("Section.TLabel", font=("Segoe UI", 10, "bold"), foreground="#34495e")
        style.configure("Info.TLabel", font=("Segoe UI", 9), foreground="#7f8c8d")
        
        # Configure frames
        style.configure("Card.TFrame", relief="solid", borderwidth=1)
        
        # Configure buttons
        style.configure("Primary.TButton", font=("Segoe UI", 10, "bold"))
        style.configure("Secondary.TButton", font=("Segoe UI", 9))
        
        # Configure entry fields
        style.configure("Modern.TEntry", padding=5)
        
    def create_widgets(self):
        # Main frame with scrollbar
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title
        title_label = ttk.Label(main_frame, text="ARR Interest Calculator", 
                               style="Title.TLabel")
        title_label.pack(pady=(0, 10))
        
        subtitle_label = ttk.Label(main_frame, text="SONIA / SOFR - Compounded in Arrears", 
                                  style="Subtitle.TLabel")
        subtitle_label.pack(pady=(0, 20))
        
        # Create notebook for tabs
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Input tab
        input_frame = ttk.Frame(self.notebook)
        self.notebook.add(input_frame, text="Input Parameters")
        self.create_input_tab(input_frame)
        
        # Results tab
        results_frame = ttk.Frame(self.notebook)
        self.notebook.add(results_frame, text="Results")
        self.create_results_tab(results_frame)
        
        # Calculation Detail tab
        detail_frame = ttk.Frame(self.notebook)
        self.notebook.add(detail_frame, text="Calculation Detail")
        self.create_detail_tab(detail_frame)
        
        # Help tab
        help_frame = ttk.Frame(self.notebook)
        self.notebook.add(help_frame, text="Help")
        self.create_help_tab(help_frame)
        
        # Calculate button and progress
        calc_frame = ttk.Frame(main_frame)
        calc_frame.pack(pady=20)
        
        self.calc_button = ttk.Button(calc_frame, text="Calculate Interest", 
                                     command=self.calculate_interest, style="Primary.TButton")
        self.calc_button.pack()
        
        # Progress bar
        self.progress = ttk.Progressbar(calc_frame, mode='indeterminate', length=300)
        self.progress.pack(pady=(10, 0))
        
        # Status bar and copyright frame
        status_copyright_frame = ttk.Frame(main_frame)
        status_copyright_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(10, 0))
        
        # Status bar
        self.status_var = tk.StringVar(value="Ready")
        status_bar = ttk.Label(status_copyright_frame, textvariable=self.status_var, 
                              relief=tk.SUNKEN, anchor=tk.W)
        status_bar.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        # Copyright notice
        copyright_text = "Â© 2024 Nicolo Zavarise - Tesselate"
        copyright_label = ttk.Label(status_copyright_frame, text=copyright_text, 
                                   style="Info.TLabel")
        copyright_label.pack(side=tk.RIGHT, padx=(10, 0))
        
    def create_input_tab(self, parent):
        # Create scrollable frame
        canvas = tk.Canvas(parent)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Data source selection section
        data_source_frame = ttk.LabelFrame(scrollable_frame, text="Rate Data Source", padding=10)
        data_source_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Data source radio buttons
        source_frame = ttk.Frame(data_source_frame)
        source_frame.pack(fill=tk.X, pady=5)
        
        ttk.Radiobutton(source_frame, text="CSV File", variable=self.data_source, 
                       value="csv", command=self.toggle_data_source).pack(anchor=tk.W)
        ttk.Radiobutton(source_frame, text="Online CSV", variable=self.data_source, 
                       value="gdrive", command=self.toggle_data_source).pack(anchor=tk.W)
        
        # File selection section (initially visible)
        self.file_frame = ttk.LabelFrame(scrollable_frame, text="CSV File Selection", padding=10)
        self.file_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(self.file_frame, text="Rate Data File:", style="Section.TLabel").pack(anchor=tk.W)
        file_entry_frame = ttk.Frame(self.file_frame)
        file_entry_frame.pack(fill=tk.X, pady=5)
        
        self.file_entry = ttk.Entry(file_entry_frame, textvariable=self.csv_path, width=50)
        self.file_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.create_tooltip(self.file_entry, "Select a CSV file with date and rate columns")
        
        browse_btn = ttk.Button(file_entry_frame, text="Browse", command=self.browse_csv, style="Secondary.TButton")
        browse_btn.pack(side=tk.RIGHT, padx=(5, 0))
        
        # Online CSV section (initially hidden)
        self.gdrive_frame = ttk.LabelFrame(scrollable_frame, text="Online CSV", padding=10)
        ttk.Label(self.gdrive_frame, text="Online CSV URL:", style="Section.TLabel").pack(anchor=tk.W)
        gdrive_entry_frame = ttk.Frame(self.gdrive_frame)
        gdrive_entry_frame.pack(fill=tk.X, pady=5)
        
        self.gdrive_entry = ttk.Entry(gdrive_entry_frame, textvariable=self.gdrive_url, width=50)
        self.gdrive_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.create_tooltip(self.gdrive_entry, "Enter online CSV URL (e.g., Google Drive sharing URL)")
        
        ttk.Label(self.gdrive_frame, text="Note: The file must be publicly accessible or shared with 'Anyone with the link'", 
                 style="Info.TLabel").pack(anchor=tk.W, pady=(5, 0))
        
        # Initialize the display
        self.toggle_data_source()
        
        # Transaction details section
        trans_frame = ttk.LabelFrame(scrollable_frame, text="Transaction Details", padding=10)
        trans_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Principal amount
        ttk.Label(trans_frame, text="Principal Amount:", style="Section.TLabel").pack(anchor=tk.W)
        principal_entry = ttk.Entry(trans_frame, textvariable=self.principal, width=20)
        principal_entry.pack(anchor=tk.W, pady=(0, 10))
        self.create_tooltip(principal_entry, "Enter the loan principal amount (e.g., 1000000.00)")
        
        # Date range
        date_frame = ttk.Frame(trans_frame)
        date_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(date_frame, text="Start Date:", style="Section.TLabel").pack(anchor=tk.W)
        self.start_date_picker = DatePicker(date_frame, textvariable=self.start_date, width=15)
        self.start_date_picker.pack(anchor=tk.W, pady=(0, 10))
        self.create_tooltip(self.start_date_picker.widget, "Select the start date of the interest period")
        
        ttk.Label(date_frame, text="End Date:", style="Section.TLabel").pack(anchor=tk.W)
        self.end_date_picker = DatePicker(date_frame, textvariable=self.end_date, width=15)
        self.end_date_picker.pack(anchor=tk.W, pady=(0, 10))
        self.create_tooltip(self.end_date_picker.widget, "Select the end date of the interest period")
        
        # Quick date buttons
        quick_dates_frame = ttk.Frame(date_frame)
        quick_dates_frame.pack(fill=tk.X, pady=(5, 0))
        
        ttk.Label(quick_dates_frame, text="Quick periods:", style="Info.TLabel").pack(anchor=tk.W)
        quick_btn_frame = ttk.Frame(quick_dates_frame)
        quick_btn_frame.pack(fill=tk.X, pady=(2, 0))
        
        ttk.Button(quick_btn_frame, text="1 Month", command=lambda: self.set_quick_period(30), 
                  style="Secondary.TButton", width=8).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(quick_btn_frame, text="3 Months", command=lambda: self.set_quick_period(90), 
                  style="Secondary.TButton", width=8).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(quick_btn_frame, text="6 Months", command=lambda: self.set_quick_period(180), 
                  style="Secondary.TButton", width=8).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(quick_btn_frame, text="1 Year", command=lambda: self.set_quick_period(365), 
                  style="Secondary.TButton", width=8).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(quick_btn_frame, text="Today", command=self.set_today, 
                  style="Secondary.TButton", width=8).pack(side=tk.LEFT)
        
        # Pricing option
        pricing_frame = ttk.Frame(trans_frame)
        pricing_frame.pack(fill=tk.X, pady=5)
        
        ttk.Label(pricing_frame, text="Pricing Option:").pack(anchor=tk.W)
        pricing_combo = ttk.Combobox(pricing_frame, textvariable=self.pricing_option, 
                                    values=["SONIA", "SOFR"], state="readonly", width=10)
        pricing_combo.pack(anchor=tk.W, pady=(0, 10))
        
        # Lookback
        ttk.Label(trans_frame, text="Lookback (Business Days):").pack(anchor=tk.W)
        ttk.Entry(trans_frame, textvariable=self.lookback, width=10).pack(anchor=tk.W, pady=(0, 10))
        
        # Rates section
        rates_frame = ttk.LabelFrame(scrollable_frame, text="Rate Parameters", padding=10)
        rates_frame.pack(fill=tk.X, padx=10, pady=5)
        
        # Margin
        ttk.Label(rates_frame, text="Margin per annum (%):").pack(anchor=tk.W)
        ttk.Entry(rates_frame, textvariable=self.margin, width=10).pack(anchor=tk.W, pady=(0, 10))
        
        # CAS
        ttk.Label(rates_frame, text="Credit Adjustment Spread per annum (%):").pack(anchor=tk.W)
        ttk.Entry(rates_frame, textvariable=self.cas, width=10).pack(anchor=tk.W, pady=(0, 10))
        
        # Margin change section
        margin_change_frame = ttk.LabelFrame(scrollable_frame, text="Margin Change (Optional)", padding=10)
        margin_change_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Checkbutton(margin_change_frame, text="Enable margin change during period", 
                       variable=self.margin_change, command=self.toggle_margin_change).pack(anchor=tk.W)
        
        self.margin_after_label = ttk.Label(margin_change_frame, text="New margin per annum (%):")
        self.margin_after_entry = ttk.Entry(margin_change_frame, textvariable=self.margin_after, width=10)
        self.margin_date_label = ttk.Label(margin_change_frame, text="Effective date:")
        self.margin_date_picker = DatePicker(margin_change_frame, textvariable=self.margin_change_date, width=15)
        
        # Pack canvas and scrollbar
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
    def create_tooltip(self, widget, text):
        """Create a tooltip for a widget."""
        def show_tooltip(event):
            tooltip = tk.Toplevel()
            tooltip.wm_overrideredirect(True)
            tooltip.wm_geometry(f"+{event.x_root+10}+{event.y_root+10}")
            
            label = tk.Label(tooltip, text=text, justify=tk.LEFT,
                           background="#ffffe0", relief=tk.SOLID, borderwidth=1,
                           font=("Segoe UI", 8))
            label.pack()
            
            def hide_tooltip(event):
                tooltip.destroy()
            
            widget.bind('<Leave>', hide_tooltip)
            tooltip.bind('<Leave>', hide_tooltip)
            
        widget.bind('<Enter>', show_tooltip)
        
    def toggle_data_source(self):
        """Toggle between CSV file and Online CSV data source."""
        # Hide all frames first
        self.file_frame.pack_forget()
        self.gdrive_frame.pack_forget()
        
        if self.data_source.get() == "csv":
            self.file_frame.pack(fill=tk.X, padx=10, pady=5)
        elif self.data_source.get() == "gdrive":
            self.gdrive_frame.pack(fill=tk.X, padx=10, pady=5)
        
    def browse_csv(self):
        filename = filedialog.askopenfilename(
            title="Select CSV File",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if filename:
            self.csv_path.set(filename)
        
    def set_quick_period(self, days):
        """Set end date based on start date plus specified days."""
        try:
            start_date = datetime.strptime(self.start_date.get(), "%Y-%m-%d").date()
            end_date = start_date + timedelta(days=days)
            self.end_date.set(end_date.strftime("%Y-%m-%d"))
        except:
            # If start date is invalid, use today as start
            today = datetime.now().date()
            self.start_date.set(today.strftime("%Y-%m-%d"))
            end_date = today + timedelta(days=days)
            self.end_date.set(end_date.strftime("%Y-%m-%d"))
        
    def set_today(self):
        """Set start date to today."""
        today = datetime.now().date()
        self.start_date.set(today.strftime("%Y-%m-%d"))
        
    def toggle_margin_change(self):
        if self.margin_change.get():
            self.margin_after_label.pack(anchor=tk.W)
            self.margin_after_entry.pack(anchor=tk.W, pady=(0, 10))
            self.margin_date_label.pack(anchor=tk.W)
            self.margin_date_picker.pack(anchor=tk.W, pady=(0, 10))
        else:
            self.margin_after_label.pack_forget()
            self.margin_after_entry.pack_forget()
            self.margin_date_label.pack_forget()
            self.margin_date_picker.pack_forget()
        
    def create_results_tab(self, parent):
        # Results text area
        self.results_text = scrolledtext.ScrolledText(parent, wrap=tk.WORD, height=20)
        self.results_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Export button
        export_frame = ttk.Frame(parent)
        export_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Button(export_frame, text="Export Results", command=self.export_results, style="Secondary.TButton").pack(side=tk.LEFT)
        ttk.Button(export_frame, text="Copy to Clipboard", command=self.copy_results, style="Secondary.TButton").pack(side=tk.LEFT, padx=(10, 0))
        ttk.Button(export_frame, text="Clear Results", command=self.clear_results, style="Secondary.TButton").pack(side=tk.LEFT, padx=(10, 0))
        
    def create_detail_tab(self, parent):
        # Create a frame for the detail view
        detail_frame = ttk.Frame(parent)
        detail_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create Treeview for daily breakdown
        columns = ('Date', 'Business Day', 'Observation Date', 'Daily Rate', 'Margin Rate', 'CAS Rate', 
                  'Daily ARR Interest', 'Daily Margin Interest', 'Daily CAS Interest', 'Cumulative Factor', 'Type')
        
        self.detail_tree = ttk.Treeview(detail_frame, columns=columns, show='headings', height=15)
        
        # Configure column headings
        self.detail_tree.heading('Date', text='Date')
        self.detail_tree.heading('Business Day', text='Business Day')
        self.detail_tree.heading('Observation Date', text='Observation Date')
        self.detail_tree.heading('Daily Rate', text='Daily Rate (%)')
        self.detail_tree.heading('Margin Rate', text='Margin Rate (%)')
        self.detail_tree.heading('CAS Rate', text='CAS Rate (%)')
        self.detail_tree.heading('Daily ARR Interest', text='Daily ARR Interest')
        self.detail_tree.heading('Daily Margin Interest', text='Daily Margin Interest')
        self.detail_tree.heading('Daily CAS Interest', text='Daily CAS Interest')
        self.detail_tree.heading('Cumulative Factor', text='Cumulative Factor')
        self.detail_tree.heading('Type', text='Day Type')
        
        # Configure column widths
        self.detail_tree.column('Date', width=100)
        self.detail_tree.column('Business Day', width=100)
        self.detail_tree.column('Observation Date', width=120)
        self.detail_tree.column('Daily Rate', width=100)
        self.detail_tree.column('Margin Rate', width=100)
        self.detail_tree.column('CAS Rate', width=100)
        self.detail_tree.column('Daily ARR Interest', width=140)
        self.detail_tree.column('Daily Margin Interest', width=140)
        self.detail_tree.column('Daily CAS Interest', width=140)
        self.detail_tree.column('Cumulative Factor', width=120)
        self.detail_tree.column('Type', width=80)
        
        # Add scrollbars
        detail_scrollbar_y = ttk.Scrollbar(detail_frame, orient=tk.VERTICAL, command=self.detail_tree.yview)
        detail_scrollbar_x = ttk.Scrollbar(detail_frame, orient=tk.HORIZONTAL, command=self.detail_tree.xview)
        self.detail_tree.configure(yscrollcommand=detail_scrollbar_y.set, xscrollcommand=detail_scrollbar_x.set)
        
        # Pack the treeview and scrollbars
        self.detail_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        detail_scrollbar_y.pack(side=tk.RIGHT, fill=tk.Y)
        detail_scrollbar_x.pack(side=tk.BOTTOM, fill=tk.X)
        
        # Buttons frame
        detail_buttons_frame = ttk.Frame(parent)
        detail_buttons_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Button(detail_buttons_frame, text="Export Detail", command=self.export_detail, style="Secondary.TButton").pack(side=tk.LEFT)
        ttk.Button(detail_buttons_frame, text="Clear Detail", command=self.clear_detail, style="Secondary.TButton").pack(side=tk.LEFT, padx=(10, 0))
        
    def create_help_tab(self, parent):
        help_text = scrolledtext.ScrolledText(parent, wrap=tk.WORD, height=20)
        help_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        help_content = """
ARR INTEREST CALCULATOR - HELP

What is this tool?
This calculator computes interest for loans using SONIA or SOFR rates with
compounded-in-arrears methodology and business day lookback.

Date Picker:
The application includes date picker widgets for easy date selection. If you have
tkcalendar installed (pip install tkcalendar), you'll get an enhanced calendar widget.
Otherwise, a basic calendar popup will be used.

Dependencies:
For enhanced features, install: pip install tkcalendar beautifulsoup4
- tkcalendar: Enhanced date picker widgets
- beautifulsoup4: Better web scraping for Bank of England data

Quick Period Buttons:
Use the quick period buttons (1 Month, 3 Months, 6 Months, 1 Year) to quickly
set common interest periods. The "Today" button sets the start date to today.

Data Sources:
  â€¢ CSV File: Upload your own rate data file
  â€¢ Bank of England: Automatically fetch SONIA rates from the official website
    (requires internet connection, only available for SONIA calculations)

CSV File Format:
Your CSV file should have:
  â€¢ Column 1: Date in YYYY-MM-DD format
  â€¢ Column 2: Daily rate (can be percent like 5.12 or decimal like 0.0512)
  â€¢ Optional header row (will be auto-detected)

Example CSV:
2024-01-01,5.12
2024-01-02,5.15
2024-01-03,5.10

Key Concepts:
  â€¢ Lookback: Number of business days to look back for rate observation
  â€¢ Margin: Additional spread added to the RFR (not compounded)
  â€¢ CAS: Credit Adjustment Spread (not compounded)
  â€¢ Day Count: ACT/365F for SONIA, ACT/360 for SOFR

Common Issues:
  â€¢ Ensure CSV has sufficient historical data for lookback period
  â€¢ Check that dates are in correct format
  â€¢ Verify rates are reasonable (typically 0-20% range)
  â€¢ Make sure end date is after start date

Input Guidelines:
  â€¢ Principal: Enter the loan amount (e.g., 1000000.00)
  â€¢ Dates: Use YYYY-MM-DD format (e.g., 2024-01-01)
  â€¢ Rates: Enter as percentages (e.g., 2.00 for 2%)
  â€¢ Lookback: Typically 5 business days for SONIA/SOFR
        """
        
        help_text.insert(tk.END, help_content)
        help_text.config(state=tk.DISABLED)
        
    def export_results(self):
        """Export results to a file."""
        if not hasattr(self, 'last_result'):
            messagebox.showwarning("No Results", "No calculation results to export")
            return
            
        filename = filedialog.asksaveasfilename(
            title="Save Results",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if filename:
            try:
                save_results_to_file(self.last_result, filename)
                messagebox.showinfo("Export Successful", f"Results saved to {filename}")
            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to save results: {str(e)}")
                
    def copy_results(self):
        """Copy results to clipboard."""
        try:
            results_text = self.results_text.get(1.0, tk.END)
            if results_text.strip():
                self.root.clipboard_clear()
                self.root.clipboard_append(results_text)
                messagebox.showinfo("Copied", "Results copied to clipboard")
            else:
                messagebox.showwarning("No Results", "No results to copy")
        except Exception as e:
            messagebox.showerror("Copy Error", f"Failed to copy results: {str(e)}")
            
    def clear_results(self):
        """Clear the results display."""
        self.results_text.config(state=tk.NORMAL)
        self.results_text.delete(1.0, tk.END)
        self.results_text.config(state=tk.DISABLED)
        
    def export_detail(self):
        """Export detail breakdown to a CSV file."""
        if not hasattr(self, 'last_detail_data'):
            messagebox.showwarning("No Detail Data", "No calculation detail to export")
            return
            
        filename = filedialog.asksaveasfilename(
            title="Save Detail Breakdown",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        
        if filename:
            try:
                with open(filename, 'w', newline='') as csvfile:
                    writer = csv.writer(csvfile)
                    # Write header
                    writer.writerow(['Date', 'Business Day', 'Observation Date', 'Daily Rate (%)', 
                                   'Margin Rate (%)', 'CAS Rate (%)', 'Daily ARR Interest', 
                                   'Daily Margin Interest', 'Daily CAS Interest', 'Cumulative Factor', 'Day Type'])
                    # Write data
                    for row in self.last_detail_data:
                        writer.writerow(row)
                messagebox.showinfo("Export Successful", f"Detail breakdown saved to {filename}")
            except Exception as e:
                messagebox.showerror("Export Error", f"Failed to save detail: {str(e)}")
                
    def clear_detail(self):
        """Clear the detail display."""
        for item in self.detail_tree.get_children():
            self.detail_tree.delete(item)
        
    def validate_inputs(self):
        """Validate all user inputs."""
        errors = []
        
        # Check data source
        if self.data_source.get() == "csv":
            if not self.csv_path.get():
                errors.append("Please select a CSV file")
            elif not os.path.exists(self.csv_path.get()):
                errors.append("Selected CSV file does not exist")
        elif self.data_source.get() == "gdrive":
            if not self.gdrive_url.get():
                errors.append("Please enter an online CSV URL")
            elif not self.gdrive_url.get().startswith("https://"):
                errors.append("Please enter a valid URL starting with https://")
            
        # Check principal
        try:
            principal = Decimal(self.principal.get())
            if principal <= 0:
                errors.append("Principal amount must be positive")
        except:
            errors.append("Invalid principal amount")
            
        # Check dates
        try:
            start = datetime.strptime(self.start_date.get(), "%Y-%m-%d").date()
            end = datetime.strptime(self.end_date.get(), "%Y-%m-%d").date()
            if end <= start:
                errors.append("End date must be after start date")
        except:
            errors.append("Invalid date format (use YYYY-MM-DD)")
            
        # Check lookback
        try:
            lookback = int(self.lookback.get())
            if lookback < 1:
                errors.append("Lookback must be at least 1 business day")
        except:
            errors.append("Invalid lookback value")
            
        # Check rates
        try:
            margin = Decimal(self.margin.get())
            if margin < 0:
                errors.append("Margin cannot be negative")
        except:
            errors.append("Invalid margin value")
            
        try:
            cas = Decimal(self.cas.get())
            if cas < 0:
                errors.append("CAS cannot be negative")
        except:
            errors.append("Invalid CAS value")
            
        # Check margin change if enabled
        if self.margin_change.get():
            try:
                margin_after = Decimal(self.margin_after.get())
                if margin_after < 0:
                    errors.append("New margin cannot be negative")
            except:
                errors.append("Invalid new margin value")
                
            try:
                margin_date = datetime.strptime(self.margin_change_date.get(), "%Y-%m-%d").date()
            except:
                errors.append("Invalid margin change date format")
                
        return errors
        
    def calculate_interest(self):
        """Perform the interest calculation."""
        # Validate inputs
        errors = self.validate_inputs()
        if errors:
            messagebox.showerror("Validation Error", "\n".join(errors))
            return
            
        try:
            # Show progress and disable button
            self.calc_button.config(state='disabled')
            self.progress.start()
            self.status_var.set("Calculating...")
            self.root.update()
            
            # Parse inputs
            principal = Decimal(self.principal.get())
            start = datetime.strptime(self.start_date.get(), "%Y-%m-%d").date()
            end = datetime.strptime(self.end_date.get(), "%Y-%m-%d").date()
            po = self.pricing_option.get()
            lookback = int(self.lookback.get())
            margin_pa = parse_rate_input(self.margin.get())
            cas_pa = parse_rate_input(self.cas.get())
            
            # Optional margin change
            margin_change_date = None
            margin_pa_after = None
            if self.margin_change.get():
                margin_pa_after = parse_rate_input(self.margin_after.get())
                margin_change_date = datetime.strptime(self.margin_change_date.get(), "%Y-%m-%d").date()
            
            # Load rates based on data source
            if self.data_source.get() == "csv":
                rates = read_rates_csv(self.csv_path.get())
            elif self.data_source.get() == "gdrive":
                self.status_var.set("Downloading CSV from online source...")
                self.root.update()
                try:
                    csv_content = download_csv_from_url(self.gdrive_url.get())
                    rates = parse_csv_content(csv_content)
                    if not rates:
                        raise ValueError("No valid rate data found in the CSV file")
                    self.status_var.set(f"Downloaded and parsed {len(rates)} rates from online source")
                except Exception as e:
                    raise ValueError(f"Failed to download CSV from online source: {str(e)}")
                
            basis = 365 if po == "SONIA" else 360
            
            # Calculate
            result = compute_interest_compounded_in_arrears(
                principal, start, end, lookback, rates, basis, margin_pa, cas_pa,
                margin_change_date=margin_change_date, margin_pa_after=margin_pa_after,
                is_sonia=(po == "SONIA"), return_daily_details=True
            )
            
            # Store result for export
            self.last_result = result
            
            # Display results
            self.display_results(result, principal, start, end, po, lookback, margin_pa, cas_pa)
            
            # Display daily details
            self.display_daily_details(result, principal, start, end, po, margin_pa, cas_pa, margin_change_date, margin_pa_after)
            
            self.status_var.set("Calculation completed successfully")
            
        except Exception as e:
            messagebox.showerror("Calculation Error", str(e))
            self.status_var.set("Calculation failed")
        finally:
            # Hide progress and re-enable button
            self.progress.stop()
            self.calc_button.config(state='normal')
        
    def display_results(self, result, principal, start, end, po, lookback, margin_pa, cas_pa):
        """Display calculation results in the results tab."""
        self.results_text.config(state=tk.NORMAL)
        self.results_text.delete(1.0, tk.END)
        
        # Determine currency based on pricing option
        currency = "GBP" if po == "SONIA" else "USD"
        
        output = f"""
{'='*60}
ARR INTEREST CALCULATION RESULTS
{'='*60}

TRANSACTION DETAILS:
  Principal Amount: {print_currency(principal, currency)}
  Pricing Option: {po}
  Day Count Basis: ACT/{result['N']}
  Lookback Period: {lookback} business day(s)
  Accrual Period: {start} to {end} ({result['dc']} calendar days)

RATE INFORMATION:
  Compounded Factor (RFR only): {result['compounded_factor']:.8f}
  RFR Annualized Rate: {result['rfr_annualized']:.6%}
  Margin Rate: {margin_pa:.6%}
  Credit Adjustment Spread: {cas_pa:.6%}
  Applicable Annualized Rate: {result['applicable_annualized_rate']:.6%}

"""
        
        # Margin breakdown if there's a step change
        pre = result["margin_breakdown"]["pre"]
        post = result["margin_breakdown"]["post"]
        if post["days"] > 0 and pre["days"] > 0:
            output += f"""MARGIN STEP CHANGE:
  {pre['days']} day(s) at {pre['margin_pa']:.6%} pa
  {post['days']} day(s) at {post['margin_pa']:.6%} pa (from {post['effective_date']})

"""
        
        output += f"""INTEREST BREAKDOWN:
  RFR Component:     {print_currency(quantize_money(result['interest_rfr']), currency)}
  Margin Component:  {print_currency(quantize_money(result['interest_margin']), currency)}
  CAS Component:     {print_currency(quantize_money(result['interest_cas']), currency)}
  TOTAL INTEREST:    {print_currency(quantize_money(result['interest_total']), currency)}

Calculation completed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        
        self.results_text.insert(tk.END, output)
        self.results_text.config(state=tk.DISABLED)
        
        # Switch to results tab
        self.notebook.select(1)
        
    def display_daily_details(self, result, principal, start, end, po, margin_pa, cas_pa, margin_change_date, margin_pa_after):
        """Display daily breakdown in the detail tab."""
        # Clear existing data
        for item in self.detail_tree.get_children():
            self.detail_tree.delete(item)
        
        # Determine currency
        currency = "GBP" if po == "SONIA" else "USD"
        
        # Get daily details if available
        if 'daily_details' not in result:
            return
            
        daily_details = result['daily_details']
        N = Decimal(result['N'])
        
        # Prepare data for display
        detail_data = []
        
        for detail in daily_details:
            date = detail['date']
            business_day = detail['business_day']
            observation_date = detail['observation_date']
            daily_rate = detail['daily_rate']
            cumulative_factor = detail['cumulative_factor']
            is_business_day = detail.get('is_business_day', False)
            
            # Determine margin rate for this date
            if margin_change_date and date >= margin_change_date:
                current_margin = margin_pa_after
            else:
                current_margin = margin_pa
            
            # Calculate daily interest components
            # Daily ARR interest is the change in cumulative factor * principal
            if len(detail_data) > 0:
                prev_factor = detail_data[-1][9]  # Previous cumulative factor (stored as Decimal)
                daily_arr_interest = (cumulative_factor - prev_factor) * principal
            else:
                daily_arr_interest = (cumulative_factor - Decimal(1)) * principal
            
            # For non-business days, ARR interest should be 0 (no compounding)
            if not is_business_day:
                daily_arr_interest = Decimal(0)
            
            # Daily margin and CAS interest (simple interest for one day)
            daily_margin_interest = (current_margin / N) * principal
            daily_cas_interest = (cas_pa / N) * principal
            
            # Format data for display
            day_type = "Business" if is_business_day else "Non-Business"
            display_row = [
                date.strftime('%Y-%m-%d'),
                business_day.strftime('%Y-%m-%d'),
                observation_date.strftime('%Y-%m-%d'),
                f"{daily_rate:.6%}",
                f"{current_margin:.6%}",
                f"{cas_pa:.6%}",
                print_currency(quantize_money(daily_arr_interest), currency),
                print_currency(quantize_money(daily_margin_interest), currency),
                print_currency(quantize_money(daily_cas_interest), currency),
                f"{cumulative_factor:.8f}",
                day_type
            ]
            
            # Store data with cumulative factor as Decimal for calculations
            detail_data.append([
                date.strftime('%Y-%m-%d'),
                business_day.strftime('%Y-%m-%d'),
                observation_date.strftime('%Y-%m-%d'),
                f"{daily_rate:.6%}",
                f"{current_margin:.6%}",
                f"{cas_pa:.6%}",
                print_currency(quantize_money(daily_arr_interest), currency),
                print_currency(quantize_money(daily_margin_interest), currency),
                print_currency(quantize_money(daily_cas_interest), currency),
                cumulative_factor,  # Keep as Decimal for calculations
                day_type
            ])
            
            # Insert into treeview
            self.detail_tree.insert('', 'end', values=display_row)
        
        # Store data for export
        self.last_detail_data = detail_data
        
def fetch_sonia_rates_from_boe(start_date: date, end_date: date) -> OrderedDict:
    """
    Fetch SONIA rates from Bank of England website.
    
    Args:
        start_date: Start date for rate data
        end_date: End date for rate data
        
    Returns:
        OrderedDict with date -> rate mapping
    """
    # Bank of England SONIA URL
    base_url = "https://www.bankofengland.co.uk/boeapps/database/fromshowcolumns.asp"
    
    # Prepare parameters for the request
    params = {
        'Travel': 'NIxSUx',
        'FromSeries': '1',
        'ToSeries': '50',
        'DAT': 'RNG',
        'FD': start_date.day,
        'FM': start_date.strftime('%b'),
        'FY': start_date.year,
        'TD': end_date.day,
        'TM': end_date.strftime('%b'),
        'TY': end_date.year,
        'FNY': '',
        'CSVF': 'TT',
        'html.x': '180',
        'html.y': '34',
        'C': '5JK',
        'Filter': 'N'
    }
    
    # Construct the full URL
    url = f"{base_url}?{urllib.parse.urlencode(params)}"
    
    try:
        # Create SSL context that handles certificate issues
        import ssl
        ssl_context = ssl.create_default_context()
        
        # For macOS, try to use the system certificates
        if HAS_CERTIFI:
            ssl_context.load_verify_locations(certifi.where())
        else:
            # If certifi is not available, try to disable verification as fallback
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
        
        # Create opener with SSL context
        opener = urllib.request.build_opener(
            urllib.request.HTTPSHandler(context=ssl_context)
        )
        urllib.request.install_opener(opener)
        
        # Fetch the data
        with urllib.request.urlopen(url, timeout=30) as response:
            html_content = response.read().decode('utf-8')
        
        # Parse the HTML content
        if HAS_BEAUTIFULSOUP:
            return parse_sonia_html_bs4(html_content)
        else:
            return parse_sonia_html_regex(html_content)
            
    except Exception as e:
        # If SSL still fails, try without verification as last resort
        try:
            import ssl
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
            
            opener = urllib.request.build_opener(
                urllib.request.HTTPSHandler(context=ssl_context)
            )
            urllib.request.install_opener(opener)
            
            with urllib.request.urlopen(url, timeout=30) as response:
                html_content = response.read().decode('utf-8')
            
            if HAS_BEAUTIFULSOUP:
                return parse_sonia_html_bs4(html_content)
            else:
                return parse_sonia_html_regex(html_content)
                
        except Exception as e2:
            raise ValueError(f"Failed to fetch SONIA rates from Bank of England: {str(e2)}")

def download_csv_from_url(url: str) -> str:
    """
    Download CSV file from online URL.
    
    Args:
        url: Online URL (supports Google Drive and other direct URLs)
        
    Returns:
        CSV content as string
    """
    try:
        # Handle Google Drive URLs
        if 'drive.google.com' in url and '/file/d/' in url:
            # Convert Google Drive sharing URL to direct download URL
            file_id = url.split('/file/d/')[1].split('/')[0]
            download_url = f"https://drive.google.com/uc?export=download&id={file_id}"
        else:
            # Use the URL directly for other sources
            download_url = url
        
        # Create SSL context
        import ssl
        ssl_context = ssl.create_default_context()
        
        if HAS_CERTIFI:
            ssl_context.load_verify_locations(certifi.where())
        else:
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE
        
        # Create opener with SSL context
        opener = urllib.request.build_opener(
            urllib.request.HTTPSHandler(context=ssl_context)
        )
        urllib.request.install_opener(opener)
        
        # Download the file
        with urllib.request.urlopen(download_url, timeout=30) as response:
            content = response.read().decode('utf-8')
        
        return content
        
    except Exception as e:
        raise ValueError(f"Failed to download CSV from online source: {str(e)}")

def parse_sonia_html_bs4(html_content: str) -> OrderedDict:
    """Parse SONIA HTML using BeautifulSoup."""
    soup = BeautifulSoup(html_content, 'html.parser')
    
    # Find the table with SONIA data
    tables = soup.find_all('table')
    rates = OrderedDict()
    
    for table in tables:
        rows = table.find_all('tr')
        for row in rows:
            cells = row.find_all(['td', 'th'])
            if len(cells) >= 2:
                try:
                    # Try to parse date and rate
                    date_str = cells[0].get_text(strip=True)
                    rate_str = cells[1].get_text(strip=True)
                    
                    # Parse date
                    date_obj = datetime.strptime(date_str, '%d %b %Y').date()
                    
                    # Parse rate (remove any non-numeric characters except decimal point)
                    rate_clean = re.sub(r'[^\d.]', '', rate_str)
                    if rate_clean:
                        rate_decimal = Decimal(rate_clean)
                        # Convert to decimal if it looks like a percentage
                        if rate_decimal > 1:
                            rate_decimal = rate_decimal / Decimal(100)
                        rates[date_obj] = rate_decimal
                        
                except (ValueError, AttributeError):
                    continue
    
    return rates

def parse_sonia_html_regex(html_content: str) -> OrderedDict:
    """Parse SONIA HTML using regex (fallback method)."""
    # Look for table rows with date and rate patterns
    # Pattern: <td>DD MMM YYYY</td><td>RATE</td>
    pattern = r'<td[^>]*>(\d{1,2}\s+[A-Za-z]{3}\s+\d{4})</td>\s*<td[^>]*>([^<]+)</td>'
    
    matches = re.findall(pattern, html_content)
    rates = OrderedDict()
    
    for date_str, rate_str in matches:
        try:
            # Parse date
            date_obj = datetime.strptime(date_str.strip(), '%d %b %Y').date()
            
            # Parse rate
            rate_clean = re.sub(r'[^\d.]', '', rate_str.strip())
            if rate_clean:
                rate_decimal = Decimal(rate_clean)
                # Convert to decimal if it looks like a percentage
                if rate_decimal > 1:
                    rate_decimal = rate_decimal / Decimal(100)
                rates[date_obj] = rate_decimal
                
        except (ValueError, AttributeError):
            continue
    
    return rates

def print_currency(amount: Decimal, currency: str = "USD") -> str:
    """Format currency amount with proper formatting."""
    return f"{currency} {amount:,.2f}"

def parse_rate_input(s: str) -> Decimal:
    """Accept decimal or percent; return decimal (e.g., 2.5 -> 0.025 if >1)."""
    x = Decimal(s.strip())
    return x / Decimal(100) if x > 1 else x

def parse_csv_content(content: str) -> OrderedDict:
    """Parse CSV content from string and return OrderedDict[date -> Decimal_rate_decimal].
    Accepts CSV with header or no header. First column is date, second is rate.
    Rate can be a percent (e.g. 5.12) or decimal (0.0512). """
    rows = []
    try:
        # Create a StringIO object to simulate file reading
        from io import StringIO
        f = StringIO(content)
        
        sniffer = csv.Sniffer()
        sample = f.read(2048)
        f.seek(0)
        try:
            dialect = sniffer.sniff(sample) if sample else csv.excel
        except csv.Error:
            dialect = csv.excel
        reader = csv.reader(f, dialect)
        # Try to skip header if the first cell is not a date
        peek = next(reader, None)
        def is_date_str(x):
            try:
                datetime.strptime(x, "%Y-%m-%d").date()
                return True
            except Exception:
                return False
        if peek is not None and not (len(peek) >= 2 and is_date_str(peek[0])):
            # treat as header, move on
            pass
        else:
            if peek is not None:
                rows.append(peek)
        for row in reader:
            if not row or len(row) < 2:
                continue
            rows.append(row)
    except Exception as e:
        raise ValueError(f"Error parsing CSV content: {str(e)}")
    
    dmap = {}
    valid_rows = 0
    for r in rows:
        try:
            d = datetime.strptime(r[0], "%Y-%m-%d").date()
        except Exception:
            continue
        try:
            raw = Decimal(str(r[1]).strip())
        except Exception:
            continue
        # If given as percent (e.g., 5.12), convert to decimal
        rate_dec = raw / Decimal(100) if raw > 1 else raw
        dmap[d] = rate_dec
        valid_rows += 1
    
    if valid_rows == 0:
        raise ValueError("No valid rate data found in CSV content")
    
    # Order by date
    return OrderedDict(sorted(dmap.items(), key=lambda kv: kv[0]))

def read_rates_csv(path: str) -> OrderedDict:
    """Return OrderedDict[date -> Decimal_rate_decimal] sorted by date.
    Accepts CSV with header or no header. First column is date, second is rate.
    Rate can be a percent (e.g. 5.12) or decimal (0.0512). """
    try:
        with open(path, 'r', newline='') as f:
            content = f.read()
        return parse_csv_content(content)
    except FileNotFoundError:
        raise ValueError(f"CSV file '{path}' not found")
    except PermissionError:
        raise ValueError(f"Permission denied accessing '{path}'")
    except Exception as e:
        raise ValueError(f"Error reading CSV file: {str(e)}")

def previous_business_day(bdays: List[date], d: date) -> date:
    """Return the greatest business day <= d. Raise if none found."""
    # bdays is sorted ascending
    # Binary search for rightmost <= d
    lo, hi = 0, len(bdays) - 1
    ans = None
    while lo <= hi:
        mid = (lo + hi) // 2
        if bdays[mid] <= d:
            ans = bdays[mid]
            lo = mid + 1
        else:
            hi = mid - 1
    if ans is None:
        raise ValueError(f"No business day on/before {d} in the supplied CSV.")
    return ans

def shift_back_business_days(bdays_index: Dict[date, int], bdays: List[date], d: date, n: int) -> date:
    """Return the business day that is n business days before business day d."""
    if d not in bdays_index:
        raise ValueError(f"{d} is not a business day in the CSV.")
    i = bdays_index[d] - n
    if i < 0:
        raise ValueError(f"CSV does not go back {n} business days before {d}. Add more history.")
    return bdays[i]

def next_business_day(bdays: List[date], d: date) -> date:
    """Return the smallest business day >= d. Raise if none found."""
    # bdays is sorted ascending
    # Binary search for leftmost >= d
    lo, hi = 0, len(bdays) - 1
    ans = None
    while lo <= hi:
        mid = (lo + hi) // 2
        if bdays[mid] >= d:
            ans = bdays[mid]
            hi = mid - 1
        else:
            lo = mid + 1
    if ans is None:
        raise ValueError(f"No business day on/after {d} in the supplied CSV.")
    return ans

def daterange(start: date, end: date):
    """Yield dates from start (inclusive) to end (exclusive)."""
    cur = start
    while cur < end:
        yield cur
        cur = cur + timedelta(days=1)

def compute_interest_compounded_in_arrears(
    principal: Decimal,
    start: date,
    end: date,
    lookback_bdays: int,
    rates: OrderedDict,
    basis_days: int,
    margin_pa: Decimal,
    cas_pa: Decimal,
    margin_change_date: Optional[date] = None,
    margin_pa_after: Optional[Decimal] = None,
    is_sonia: bool = False,
    return_daily_details: bool = False,
) -> dict:
    """Compute interest components and return a dict with details.

    - Compounds RFR daily with business-day lookback (without observation shift).
    - Adds Margin and CAS (per annum) *after* compounding, using day-count fraction.
    - Supports a single margin change on `margin_change_date` (inclusive).

    Returns dict with keys:
      interest_total, interest_rfr, interest_margin, interest_cas,
      compounded_factor, rfr_annualized, applicable_annualized_rate, dc, N,
      margin_breakdown: { 'pre': {'days': int, 'margin_pa': Decimal},
                          'post': {'days': int, 'margin_pa': Decimal, 'effective_date': date} }
    """
    if lookback_bdays < 1:
        raise ValueError("Lookback must be at least 1 business day.")
    if end <= start:
        raise ValueError("End date must be after start date.")
    bdays = list(rates.keys())
    if not bdays:
        raise ValueError("No rates found in CSV.")
    bdays_index = {bd: i for i, bd in enumerate(bdays)}

    # Ensure coverage: earliest observation needed for the first accrual day
    first_needed_bd = previous_business_day(bdays, start)
    _ = shift_back_business_days(bdays_index, bdays, first_needed_bd, lookback_bdays)

    N = Decimal(basis_days)
    C = Decimal(1)  # compounded factor for the RFR piece only
    
    # Track daily details if requested
    daily_details = []
    if return_daily_details:
        daily_details = []

    # Process each business day in the period
    current_date = start
    while current_date < end:
        # Find the next business day from current_date
        if current_date in bdays:
            # Current date is a business day
            business_day = current_date
            next_bd = next_business_day(bdays, current_date + timedelta(days=1))
        else:
            # Current date is not a business day, find the previous business day
            business_day = previous_business_day(bdays, current_date)
            next_bd = next_business_day(bdays, current_date)
        
        # Calculate the number of calendar days this business day rate applies to
        days_applied = min((next_bd - current_date).days, (end - current_date).days)
        
        # Get the observation date for this business day (with lookback)
        obs = shift_back_business_days(bdays_index, bdays, business_day, lookback_bdays)
        r = rates[obs]  # decimal (e.g., 0.0512 for 5.12%)
        
        # Apply the rate for the number of days it covers (business-day product)
        # Formula: (1 + (r * days_applied) / N) â€” matches Compounded-in-Arrears using n_i calendar days per business day
        period_factor = Decimal(1) + (r * Decimal(days_applied) / N)
        C *= period_factor
        
        # Apply 18 decimal precision for SONIA calculations
        if is_sonia:
            C = C.quantize(Decimal('0.000000000000000001'), rounding=ROUND_HALF_UP)
            
        # Store daily details if requested
        if return_daily_details:
            # Add entries for each calendar day this business day rate applies to
            for i in range(days_applied):
                detail_date = current_date + timedelta(days=i)
                if detail_date < end:  # Ensure we don't go beyond end date
                    daily_details.append({
                        'date': detail_date,
                        'business_day': business_day,
                        'observation_date': obs,
                        'daily_rate': r,
                        'cumulative_factor': C,
                        'days_applied': days_applied,
                        'is_business_day': detail_date == business_day
                    })
        
        # Move to the next date to process
        current_date += timedelta(days=days_applied)

    dc = Decimal((end - start).days)  # calendar days in the accrual period
    dcf_total = dc / N

    # Margin calculation with a single step change
    pre_days = int(dc)  # default all pre if no change
    post_days = 0
    m1 = margin_pa
    m2 = margin_pa_after if margin_pa_after is not None else margin_pa
    eff = None

    if margin_change_date is not None:
        eff = margin_change_date
        if eff <= start:
            # Entire period uses new margin
            pre_days = 0
            post_days = int(dc)
            m1 = m2
        elif eff >= end:
            # Change after the period end -> ignore
            pre_days = int(dc)
            post_days = 0
            m2 = m1
        else:
            pre_days = (eff - start).days
            post_days = (end - eff).days  # eff is inclusive for 'post' segment

    dcf_pre = Decimal(pre_days) / N
    dcf_post = Decimal(post_days) / N

    interest_rfr = (C - Decimal(1)) * principal
    interest_margin = (m1 * dcf_pre + m2 * dcf_post) * principal
    interest_cas = cas_pa * dcf_total * principal
    interest_total = interest_rfr + interest_margin + interest_cas

    # Annualized representations (for display)
    rfr_annualized = (C - Decimal(1)) * (N / dc)
    # Weighted average margin over the period
    margin_pa_weighted = (m1 * dcf_pre + m2 * dcf_post) / (dcf_total if dcf_total != 0 else Decimal(1))
    applicable_annualized_rate = rfr_annualized + margin_pa_weighted + cas_pa

    result = {
        "interest_total": interest_total,
        "interest_rfr": interest_rfr,
        "interest_margin": interest_margin,
        "interest_cas": interest_cas,
        "compounded_factor": C,
        "rfr_annualized": rfr_annualized,
        "applicable_annualized_rate": applicable_annualized_rate,
        "dc": int(dc),
        "N": int(N),
        "margin_breakdown": {
            "pre": {"days": pre_days, "margin_pa": m1},
            "post": {"days": post_days, "margin_pa": m2, "effective_date": eff},
        },
    }
    
    # Add daily details if requested
    if return_daily_details:
        result["daily_details"] = daily_details
    
    return result

def quantize_money(x: Decimal) -> Decimal:
    return x.quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)

def save_results_to_file(result: dict, filename: str = None):
    """Save results to a JSON file."""
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"arr_calculation_{timestamp}.json"
    
    try:
        # Convert Decimal objects to strings for JSON serialization
        json_result = {}
        for key, value in result.items():
            if key == "margin_breakdown":
                json_result[key] = {}
                for subkey, subvalue in value.items():
                    if subkey == "effective_date" and subvalue:
                        json_result[key][subkey] = subvalue.isoformat()
                    else:
                        json_result[key][subkey] = str(subvalue) if isinstance(subvalue, Decimal) else subvalue
            else:
                json_result[key] = str(value) if isinstance(value, Decimal) else value
        
        with open(filename, 'w') as f:
            json.dump(json_result, f, indent=2)
    except Exception as e:
        raise ValueError(f"Could not save results: {str(e)}")

def main():
    """Main application function."""
    root = tk.Tk()
    app = ARRCalculatorGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
